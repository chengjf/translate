原文地址[http://www.reactivemanifesto.org/]
奔向响应式架构的需求
--
应用的需求在这些年中发生了戏剧性的变化。几年前，一个大型的应用只不过十几台服务器，几秒的响应时间，几个小时的线下维护和GB级别的数据。而今天，应用被部署在任何地方，从移动设备到运行着几千个多核处理器的云计算集群上。用户期望毫秒级甚至微秒级的响应速度，和全年不停的运行。数据也扩展到PB级别。

最初，在具有创新精神的互联网驱动的公司中，如Google或者Twitter，他们应用的特点就是面向不同的行业。金融和电信是最早采取新措施来适应新需求的行业，其他行业紧随其上。

新需求催生新技术。以前的解决方案强调服务器和容器的管理。如果有更大的需求，就通过买更大的服务器和使用多线程并发处理。复杂的，低效的和昂贵的专利解决方案中，经常充斥着额外的服务器的字眼。

但是今天，形成了一个新的架构，它使得开发者有概念去构建一个可以适应今天需求的应用。我们把这种架构叫做***响应式架构***。响应式架构允许开发者去构建一个事件驱动的，可扩展的，有弹性的和易响应的系统：传递高质量的响应让用户体验有实时的感觉，有一个可扩展的有弹性的应用栈支撑，可以部署在多核系统和云计算架构上。这篇响应式宣言描述了采用响应式架构的决定性的特点。

响应式架构
--
Merriam-Webster将响应式定义为***对刺激源的快捷反应***。举个例子，组件都是激活的，都准备着接受事件。这个定义抓住了响应式架构的本质，关注系统的以下方面：
* 对事件的反应，基于事件驱动的特性使得它有了下面的特性
* 对加载的反应，关注于通过避免对共享资源的竞争而实现的可扩展性
* 对失败的反应，构建一个有能力在任何情形下都能恢复运转的系统
* 对用户的反应，杰出的响应时间使得用户几乎忽略了加载

上述中的每一个特性都是一个响应式应用的必备特征。虽然它们之间有依赖，但是并不像标准分层应用架构那种有层级的感觉。他们反而共同描述了在整个技术架构中需要应用的设计特性：
* 事件驱动-event-driven
* 可扩展性-scalable
* 可收缩性（弹性）-resilient
* 易响应性-responsive

下面，我们将对这四个特性进行深度探讨，看看它们之间有着怎样的联系。

事件驱动
--
####重要性

一个建议在异步通讯的松耦合设计上的应用，要比单纯基于同步方法调用上的应用好很多。发送者和接受者无需关注事件实现细节，只需关注与通讯的内容即可。这样的设计，使得应用易于扩展，易于升级和维护，给以应用更大的灵活性，减少维护费用。
由于异步通讯的接收者可以保留一些资源直到事件发生或者消息被接收，那么使用事件驱动的方式就能更加有效的利用这些存在的资源，允许大量接收者共享一个硬件线程。这样，一个非阻塞的应用就能比传统基于阻塞的同步和通讯原语的应用，拥有更低的延迟和更高的吞吐量。这个低操作成本的结果提高了资源利用率，迎合了终端用户。
####关键组成部分

在一个事件驱动的应用中，各个组件之间通过事件的生产者和消费者进行交互，这些事件是分离的，描述了事件的信息。这些事件通过异步和非阻塞的方法进行发送和接收。事件驱动的系统趋向依赖于推（push），而不是拉（pull）或轮询（poll）。例如，当资源可用时，事件驱动的系统就会把资源推给消费者，而不是让消费者持续请求资源或者等待资源。

* 事件的**异步**发送，也叫做消息传递，意味着这个应用是设计上高并发的，不发生变化就能充分利用多核硬件。一个CPU上的任何一个核心都能够用来处理任何消息事件，使得并行的可能性大大的提高。
* **阻塞**意味着应用随时随刻可以响应用户的请求成为了可能，甚至是系统奔溃或者宕机。所有资源的请求都能够得到响应，那么例如CPU，内存和网络资源必须不能被独占。这样，就能够带来低延迟，高吞吐量和更好的可扩展性。

传统的服务器端架构依赖于对单个线程上可变状态的共享和阻塞操作。这样就导致了当扩展该系统以适应变化的需求时变得非常困难。可变状态的共享需要同步机制，这就很容易带来复杂性和不确定，使得程序代码很难理解和维护。通过阻塞让一个线程进入休眠，会消耗有限的资源，同时唤醒该线程也会有代价。

事件产生和执行的解耦还是允许运行平台关注同步的细节和事件在线程间分发的机制，同时编程抽象已经上升到业务流程的水平。那些同步和分发的细节是运行平台需要关心的，而你应该思考事件在系统内部的扩散和组建之间的交互，而不是花时间在那些微不足道的低级别原语上比如线程和锁。

事件驱动的系统中，组件和子系统之间是松耦合的关系。如我们想看到的那样，这种间接的关系，是可扩展性和可伸缩性的先决条件之一。通过移除组件之间复杂和强壮的依赖关系，基于事件驱动的应用扩展的话，只会对原有应用带来最小的影响。

当一个系统受到高性能和良好可扩展性的压力的时候，预估瓶颈发生的位置是非常困难的。因此，整个解决方案基于异步和非阻塞就非常重要了。在一个典型的例子中，从用户在UI（浏览器，REST客户端或其他）中请求开始，到web层的请求解析和分发，再到中间层的服务组件，从头到尾的缓存和数据库，都要求设计是事件驱动的。如果上述任何一层没有参与进来，比如对数据库的阻塞调用，基于可变状态的共享，代价高昂的同步方法的调用，都会使得整个流水线停滞，用户将承受高延迟和低可扩展性。

一个应用必须从上到下都是能响应的。

消除这些链中最弱的一环，这个需求已经被Amdahl定律很好的表示出来了，维基百科上是这样描述的：

在一个使用多进程的并行计算中，一个程序想要提速，受限于程序中序列化程度。比如，如果一个程序中95%都可以并行执行，那么理论上的最大提速可以达到20%，不管使用多少进程。

可扩展性
--
####重要性

在韦氏词典中，可扩展性（scalable）定义是“能够按要求容易的进行扩展和升级”。一个可扩展的应用能够根据它的使用情况进行扩大和延伸。通过往应用中加入弹性的选项可以实现可扩展性，这些选项可以按要求向外或向内扩展（添加或删除节点）。此外，这种架构无需重新设计或者重写应用，就能够轻松的扩大或缩小（部署在一个CPU多或少的节点上）。这些弹性的加入，使得在云计算环境中最小化应用的费用成为了可能，你能从用多少付多少（pay-for-what-you-use）模型中获益。

可扩展性还可以帮助控制风险：如果提供很少的硬件，随着用户的增加会导致用户不满从而失去消费者；如果提供很多的硬件，那么就会有操作人员和资源空闲，导致不必要的花费。一个可扩展性的解决方案还能够减缓结束一个不能使用最新硬件的应用的风险，我们能够预见，在未来的十年会有数百的处理器甚至上千的硬件线程，会硬件充分利用它们的潜能，这就需要应用在一个非常精细的水平上也要保持可扩展性。

####关键组成部分

一个建立在异步消息传递基础上的事件驱动系统提供了可扩展性的基础。组件和子系统之间的松耦合和位置独立性使得扩展系统到多个节点成为了可能，同时仍然保有相同语义的编程模型。增加更多的组件实例大大提升了系统执行事件的容量。就实现方式而言，使用多核进行扩展，和在数据中心或集群上使用多个节点进行扩展是没有什么不同的。这个应用的拓扑结构决定了它的部署方式，是采用配置，还是通过自适应算法，亦或是两者皆有。我们称之为位置透明性（location transparency）。

我们的目的并不是尝试实现一个透明的分布式计算，分布式对象或RPC风格的通讯，这些以前都尝试过并且失败了，了解这一点是非常重要的。相反的，我们要拥抱网络，通过使用异步消息传递在编程模型中直接表示。真正的可扩展性自然涉及分布式计算和节点间的通讯。这些节点间的通讯意味着遍历整个网络，而我们知道那根本就是不可能的。所以在网络编程模型中显式的添加约束，进行平衡，考虑故障情况是非常重要的，而不是把它们藏在试图“简化”事情的漏洞百出的抽象上。因此，提供一些解决分布式环境中典型问题的公用模块和编程工具是很重要的，比如实现一致性的机制或者是提供高可靠性的消息抽象。

可伸缩性
--
####重要性

应用停机对任何一个业务来说都是毁坏性最大的几个问题之一。通常的含义就是操作简单的停止了，让收入减少。长远看来会导致用户不满，应用口碑下降，从而严重的损害该业务。令人惊奇的是，应用的可伸缩性是其中一个需求，它可以很大程度上忽略该问题或使用相应的技术进行改造。这通常意味着使用太粗糙的工具在错误的粒度水平上讨论问题。一个经常用到的技术就是使用应用服务器集群从运行时或服务器故障中进行恢复。不幸的是，服务器故障切换的代价非常高，并且很危险，因为可能导致级联的故障从而搞垮整个集群。原因就是将故障管理放在了一个错误的粒度水平上。我们应该将关注点放在组件水平上精细的可伸缩性上。

在韦氏词典中，可伸缩性的定义如下：
* 一种物质或物体恢复原形的能力
* 从故障中迅速恢复的能力

在一个可交互的应用中，可伸缩性并不是事后才想到的，而是一开始就是设计的组成部分之一。在编程模型中，第一类构造都提供了方法来对故障进行交互和管理，这样使得应用具有高度的容错性，可以在运行时进行恢复和修复。传统的错误处理并不能够实现上述所描述的。因为传统中的错误处理在局部是保守的，而在全局上又是太过激进的，你只能在故障发生的正确的时间和正确的地点进行异常处理，亦或者只能对整个应用实例进行故障切换。

####关键组成部分

为了管理故障，我们需要将这些故障隔离开来，以免这些故障扩散到那些运行良好的组件去。同时还需要时刻关注这些故障，从而可以在故障上下文以外的一个安全点对这些故障进行管理。闪入头脑的一个模式就是舱壁模式。系统是由安全的组件构建的，因此当其中一个组件出现故障后，其他组件并不会受到影响。这就避免了级联故障，同时也允许独立的管理这些故障。

在拥有可扩展性的事件驱动模型中，同样需要必备的原语来理解故障管理模型。在事件驱动模型中，松耦合提供了完全的隔离组件，这样故障信息就会同它们的上下文一期捕获，然后封装成消息发往其他组件，从而进行检测，然后决定如何响应。

这样构造起来的系统，业务逻辑非常干净，远离了异常处理。那些故障被显式的建模起来，通过声明的方式进行隔离，观察，管理和配置。同时系统还可以自动的修复和恢复。当整个系统是使用分层的方式构建的时候，它工作起来是最好的，就像一个大公司，问题产生的时候，会一层一层向上汇报，直到能处理的那层为止。

这种模型的优美之处在于它是一个纯净的基于事件驱动，构建在可交互组件和异步事件上的-位置透明性。这实际上意味着，你可以在分布式环境中使用和本地 上下文一样的语义。

可响应性
----
####重要性
在韦氏词典中，可响应性被定义为“快速响应和适当反应”。我们在这儿使用该词的一般解释，它不应该和响应式Web设计搞混。响应式Web设计主要指的是CSS媒体查询和渐进增强。

可响应性的应用是实时的，迷人的，丰富的和可协作的。在商业上，经常通过可响应的交互体验，弹出一个窗口来欢迎它们的客户。这使得它们更加高效，给客户产生一种连接的感觉，准备好了去解决问题和完成任务。一个例子就是Google Docs，它允许用户协同编辑文档，实时的可以看到对方的编辑和注释。

对事件可响应的应用一定要及时的做出反应，甚至是在故障发生的情况下。如果一个应用在限制的时间内没有做出反应，或者有延迟，那实际上是不可用的，也缺乏弹性。

硬实时系统的约束之多，达到了诸如武器或药品管理系统中故障的数量。但是，不是所有的应用都有如此严格的约束。许多应用中都会看到快速减少响应的工具，比如金融交易系统可以丢失当前交易而没有响应。

大部分主流的应用，比如零售品的浏览和支付，随着响应时间的增加，浏览量和交易量是下降的。用户和响应式应用进行交互，会使得用户有更多的采购。

####关键组成部分

可交互应用使用观察者模型，事件流和有状态的客户端。

观察者模型使得其他系统可以接收到状态变化的事件。这样可以提供在用户和系统之间提供一条连接。例如，很多用户同时对一个模型进行处理，这些处理结果可以双向的在它们之间同步，就好像这个模型没有锁的限制在分享。

事件流形成了连接构造的基本抽象。维持事件流的可响应性，意味着避免了阻塞，代之以异步或者非阻塞的变换和通信。

可交互应用信奉算法复杂度，部署了大量测试来保证在无负载下，响应事件要在O(1)事件内返回，最迟不能超过O(log n)。可以包括一些扩展因子，但并不受限于用户，会话，产品和交易。

* 他们部署了大量的策略来保证在忽略负载的情况下，系统响应可以保持一致：
在网络流量突然增加的情况下，响应式应用对诸如IO和并发数据交互这些代价昂贵的操作进行了缓存。通过对资源的定量连接来保证延迟一致。
* 在适当压力下，队列也是有大小限制的。队列长度通常使用利特尔法则（Little's law）来决定。
* 系统要有适当的容量来进行检测
* 故障要使用合适的策略进行隔离，当断路器（circuit breakers）发生时策略要可用

就拿基于富客户端浏览器或者移动的应用举例，看看它们是怎样带来迷人的用户体验的。这个应用可以执行逻辑，并且在客户端保存状态。观察者模型提供了机制，当状态发生变化的时候实时更新UI。诸如WebSocket和Server-Sent Events的技术，使用事件流的推技术直接和客户端的UI连接，这样事件驱动系统就从后端扩展到了客户端。它允许可交互应用使用异步和非阻塞的数据交换，通过可扩展和扩伸缩的方式，将事件推送至浏览器和移动应用。

现在，大脑中应该清楚的指导这四个特质（事件驱动，可扩展性，扩伸缩性和可响应性）是如何相互关联从而形成一个连贯的整体。

结论
--
可交互应用是解决现在软件开发中大部分挑战的一个平衡的方案。使用事件驱动，基于消息的基础上，系统可以提供工具来确保可扩展性和可伸缩性。除此之外，还提供了了丰富的，可响应的UI。我们希望，在未来的几年中，越来越多的系统将会使用响应式的架构。
